# ============================================
# nginx Reverse Proxy Config
# ============================================
#
# ROLE IN THE STACK:
#   Browser → nginx:8080 → backend:3000  (API / WebSocket / static files)
#                        → frontend:5173 (Svelte/Vite dev server + HMR)
#
# nginx sits in front of everything. The browser only ever talks to port 8080.
# nginx reads the URL path and decides where to forward the request.
#
# ============================================
#
# CONCEPT: upstream blocks
# ────────────────────────
#   upstream backend  { server backend:3000; }
#   upstream frontend { server frontend:5173; }
#
#   "backend" and "frontend" are Docker service names (from docker-compose.yml).
#   Docker's internal DNS resolves them automatically inside the app-network.
#   Defining them as upstream groups lets nginx reference them by name in
#   proxy_pass, and makes it easy to add load balancing later if needed.
#
# CONCEPT: proxy_pass
# ───────────────────
#   proxy_pass http://backend/api/;
#   nginx forwards the request to the upstream server and streams the response
#   back to the browser. The client never directly connects to backend or frontend.
#
# CONCEPT: proxy_set_header
# ─────────────────────────
#   By default, nginx strips most headers when forwarding. These headers restore
#   useful context for the upstream server:
#
#   Host                  → original Host header (e.g. "localhost")
#   X-Real-IP             → client's real IP address
#   X-Forwarded-For       → list of IPs the request passed through (proxy chain)
#   X-Forwarded-Proto     → original scheme: "http" or "https"
#
#   Without these, the backend would see nginx's internal IP as the client.
#
# CONCEPT: proxy_http_version 1.1
# ────────────────────────────────
#   HTTP/1.0 closes the connection after each request (no keep-alive).
#   HTTP/1.1 keeps it open — required for WebSocket upgrades and more efficient
#   for multiple sequential requests to the same upstream.
#
# CONCEPT: WebSocket upgrade (Upgrade + Connection headers)
# ──────────────────────────────────────────────────────────
#   WebSocket starts as a normal HTTP/1.1 request, then asks to "upgrade":
#
#   Client → nginx:
#     GET /ws HTTP/1.1
#     Upgrade: websocket
#     Connection: Upgrade
#
#   nginx must forward these headers upstream, otherwise the upgrade handshake
#   fails and the WebSocket connection is rejected.
#
#   proxy_set_header Upgrade    $http_upgrade;   ← passes "websocket"
#   proxy_set_header Connection "upgrade";        ← signals protocol switch
#
#   After the handshake, the connection becomes a persistent TCP tunnel.
#   That's why WebSocket timeouts are set to 3600s (1 hour), not 60s.
#
# CONCEPT: SPA fallback (production only)
# ────────────────────────────────────────
#   In production, the frontend is compiled to static files (dist/).
#   The production nginx stage uses:
#
#     location / {
#       try_files $uri $uri/ /index.html;
#     }
#
#   For a request like /game/lobby:
#     1. $uri   → look for file  .../game/lobby  → miss
#     2. $uri/  → look for dir   .../game/lobby/ → miss
#     3. fallback → serve /index.html → Svelte client-side router takes over
#
#   In dev (this file), there's no SPA fallback needed — Vite handles routing.
#
# CONCEPT: Why nginx and not just Node for the frontend?
# ───────────────────────────────────────────────────────
#   Svelte + Vite outputs static HTML/JS/CSS. At runtime there's no Node process.
#
#   ┌─────────────────────┬──────────────────────────────┬──────────────────────┐
#   │ Approach            │ Pros                         │ Cons                 │
#   ├─────────────────────┼──────────────────────────────┼──────────────────────┤
#   │ nginx (current)     │ Tiny (~40MB), fast, prod-grade│ Config to learn     │
#   │ vite preview (Node) │ Stays in JS ecosystem        │ 180MB, NOT for prod  │
#   │ serve (npm)         │ Simple                       │ 180MB, less features │
#   │ Caddy               │ Auto-HTTPS, simple config    │ Extra dependency     │
#   └─────────────────────┴──────────────────────────────┴──────────────────────┘
#
# ============================================

# --- Upstream definitions ---
# Docker DNS resolves "backend" via the app-network.
# Frontend is expected to run locally on the host machine in backend-only mode.
upstream backend {
    server backend:3000;
}

upstream frontend {
    server host.docker.internal:5173;
}

server {
    listen 80;
    server_name localhost;

    # Max upload size — increase if users upload large files (avatars, etc.)
    client_max_body_size 10M;

    # Logs are viewable with: docker compose logs nginx  or  make logs-nginx
    access_log /var/log/nginx/access.log;
    error_log  /var/log/nginx/error.log;

    # ─────────────────────────────────────────
    # API routes → backend
    # /api/ prefix is preserved (proxy_pass also ends with /api/)
    # Example: /api/v1/users  →  backend:3000/api/v1/users
    # ─────────────────────────────────────────
    location /api/ {
        proxy_pass http://backend/api/;
        proxy_http_version 1.1;

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Standard timeouts — increase for slow/long-running API calls
        proxy_connect_timeout 60s;
        proxy_send_timeout    60s;
        proxy_read_timeout    60s;
    }

    # ─────────────────────────────────────────
    # Health + direct backend utility routes
    # ─────────────────────────────────────────
    location /ping {
        proxy_pass http://backend/ping;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
    }

    location /health {
        proxy_pass http://backend/health;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
    }

    # ─────────────────────────────────────────
    # Static file serving (avatars, uploads, etc.)
    # Served by the backend's fastify-static plugin from /app/static/
    # ─────────────────────────────────────────
    location /static/ {
        proxy_pass http://backend/static/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
    }

    # ─────────────────────────────────────────
    # WebSocket → backend
    # Requires HTTP/1.1 + Upgrade + Connection headers (see concept above)
    # Timeout is 1 hour — WS connections are long-lived (game session duration)
    # ─────────────────────────────────────────
    location /ws {
        proxy_pass http://backend/ws;
        proxy_http_version 1.1;

        # WebSocket handshake headers — must not be removed
        proxy_set_header Upgrade    $http_upgrade;
        proxy_set_header Connection "upgrade";

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Long timeout: WS connections stay open for the full session
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    # ─────────────────────────────────────────
    # Frontend → Svelte/Vite dev server
    # Catch-all: anything not matched above goes here
    # Also proxies Vite HMR (hot module reload) which uses a WebSocket
    # internally to push code changes to the browser in real time
    # ─────────────────────────────────────────
    location / {
        proxy_pass http://frontend;
        proxy_http_version 1.1;

        # Required for Vite HMR: browser opens a WS to receive live reload events
        proxy_set_header Upgrade    $http_upgrade;
        proxy_set_header Connection "upgrade";

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
